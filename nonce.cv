type keyseed [fixed, large, bounded].
type key [bounded].
type seed [fixed, bounded].
type iv [fixed, large].
proba Penc.

fun injbot(bitstring): bitstringbot [compos].
forall x: bitstring; injbot(x) <> bottom.

fun kgen(keyseed): key.
fun enc(bitstring, key, iv): bitstring.
fun dec(bitstring, key, iv): bitstringbot.

forall m: bitstring, r: keyseed, init: iv;
    dec(enc(m, kgen(r), init), kgen(r), init) = injbot(m).

type nonce [bounded].
fun nonce_to_bits(nonce): bitstring.

const X: bitstring.

implementation
    type keyseed = 128;
    type key = 128;
    type iv = 128;
    type nonce = 64;
    fun injbot = "" [inverse = "base.injbot_inv"];
    fun nonce_to_bits = "";
    fun enc = "crypto.sym_enc";
    fun dec = "crypto.sym_dec";
    fun kgen = "";
    const X = "b'X'".

param N.

channel cstart, start, cA1, cA2, cA3 , cA4, cB1, cB2.

let Pa = A {
    in(cA1, (=X));
    new x: nonce;
    new init: iv;
    out(cA2, (init, enc(nonce_to_bits(x), Kab, init)));
    in(cA3, (init': iv, e: bitstring));
    let injbot((=X, =x, m: bitstring)) = dec(e, Kab, init') in
    out(cA4, ()) }.

let Pb = B {
    in(cB1, (init: iv, e: bitstring));
    let injbot(f) = dec(e, Kab, init) in
    new m: nonce;
    new init': iv;
    out(cB2, (init', enc((X, f, nonce_to_bits(m)), Kab, init'))) }.

process
    Keygen [Kab > keyfile] {
        in(cstart, ());
        new r: keyseed;
        let Kab: key = kgen(r) in
        out(start, ()) };
        ((!N Pa) | (!N Pb))

(* vim: set et sw=4 ts=4 sts=4: *)
