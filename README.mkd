This repository contains the supporting library for my CryptoVerif [Python implementations fork](https://github.com/mgrabovsky/cryptoverif-py) along with two examples of its usage (adapted from the original CryptoVerif code).


## Prerequisites

To build the Python implementation files, you will need the [Python implementations](https://github.com/mgrabovsky/cryptoverif-py-lib) CryptoVerif fork.

To run the examples, you will need Python 3.

To run the fancy Woo–Lam shared key protocol example, you will need [Docker](http://www.docker.com/) and the Python libraries listed in `wlskout/requirements.txt` as well.

## Building and running

### Needham–Schroeder public key protocol

The CryptoVerif script for this file is [`nspk3tbl.ocv`](./nspk3tbl.ocv) in the root directory. The example is to be run in the `nsout/` directory.

To run this example, edit `nsout/Makefile` and modify the `CV` to point to the executable of the CryptoVerif fork. Then, in the `nsout/` directory, run
```sh
$ make impl
$ make test
```

This will generate the Python implementation files that correspond to the CryptoVerif protocol script, and subsequently run the testing script. The keys are automatically generated by the library.

### Woo–Lam shared key protocol

The associated CryptoVerif script is in the [`woolamsk.cv`](./woolamsk.cv) file. The unverified parts of the implementation are in the `wlsout/` directory.

To run this example, edit `wlskout/Makefile` and modify the `CV` to point to the executable of the CryptoVerif fork. To install the required Python libraries, it is recommended to use a sandbox:
```sh
$ virtualenv env
$ source env/bin/activate
$ pip install -r requirements.txt
```

To run the example, you will first need to generate the implementation files and secret shared keys:
```sh
$ make impl
$ make keys
```

You can then create the Docker containers:
```sh
$ make docker
```

This will create two containers named `wlsk_server` and `wlsk_responder`. It is recommended to run those interactively in separate tmux panes so that you can see what's going on. Once you run the responder container, it's going to ask you for the IP of the server one, which should be available in the server container's output.

Finally, run the initiator script:
```sh
$ python initiator.py
```

It will ask you for the responder's address, which should be available in the corresponding container's output.

## Licence

See the [`LICENSE`](./LICENSE) file for details.

